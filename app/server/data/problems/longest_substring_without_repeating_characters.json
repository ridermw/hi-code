{
  "id": "longest_substring_without_repeating_characters",
  "title": "Longest Substring Without Repeating Characters",
  "statement": "Given a string s, return the length of the longest substring that contains no repeated characters by sliding a window and adjusting it when duplicates appear.",
  "signature": "int LengthOfLongestSubstring(string s)",
  "category": "Sliding Window",
  "difficulty": "Medium",
  "sections": {
    "algorithms": [
      { "id": "alg-1", "label": "Sliding window with hash map to track last seen indices and shrink on duplicates" },
      { "id": "alg-2", "label": "Expand window greedily without shrinking when repeats appear" },
      { "id": "alg-3", "label": "Two-pointer scan that restarts whenever a duplicate is found" },
      { "id": "alg-4", "label": "Sort characters then scan for the longest run of distinct values" },
      { "id": "alg-5", "label": "Depth-first search over all substrings to find the longest unique segment" },
      { "id": "alg-6", "label": "Binary search on length with a checksum to guess if a unique substring exists" }
    ],
    "implementations": [
      {
        "id": "impl-1",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    var lastSeen = new Dictionary<char, int>();\n    int left = 0, max = 0;\n    for (int right = 0; right < s.Length; right++)\n    {\n        char c = s[right];\n        if (lastSeen.TryGetValue(c, out int prev) && prev >= left)\n        {\n            left = prev + 1;\n        }\n        lastSeen[c] = right;\n        max = Math.Max(max, right - left + 1);\n    }\n    return max;\n}\n```"
      },
      {
        "id": "impl-2",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    var set = new HashSet<char>();\n    int best = 0;\n    foreach (char c in s)\n    {\n        if (set.Contains(c))\n        {\n            set.Clear();\n        }\n        set.Add(c);\n        best = Math.Max(best, set.Count);\n    }\n    return best;\n}\n```"
      },
      {
        "id": "impl-3",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    int best = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        var set = new HashSet<char>();\n        for (int j = i; j < s.Length && !set.Contains(s[j]); j++)\n        {\n            set.Add(s[j]);\n            best = Math.Max(best, j - i);\n        }\n    }\n    return best;\n}\n```"
      },
      {
        "id": "impl-4",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    if (string.IsNullOrEmpty(s)) return 0;\n    var queue = new Queue<char>();\n    var seen = new HashSet<char>();\n    int best = 0;\n    foreach (char c in s)\n    {\n        if (seen.Contains(c))\n        {\n            queue.Clear();\n            seen.Clear();\n        }\n        queue.Enqueue(c);\n        seen.Add(c);\n        best = Math.Max(best, queue.Count);\n    }\n    return best;\n}\n```"
      },
      {
        "id": "impl-5",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    int best = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        var set = new HashSet<char>();\n        for (int j = i; j < s.Length; j++)\n        {\n            if (set.Add(s[j]))\n            {\n                best = Math.Max(best, set.Count);\n            }\n        }\n    }\n    return best;\n}\n```"
      },
      {
        "id": "impl-6",
        "label": "```csharp\npublic int LengthOfLongestSubstring(string s)\n{\n    int best = 0, current = 0;\n    for (int i = 0; i < s.Length; i++)\n    {\n        if (i > 0 && s[i] == s[i - 1])\n        {\n            current = 1;\n        }\n        else\n        {\n            current++;\n        }\n        best = Math.Max(best, current);\n    }\n    return best;\n}\n```"
      }
    ],
    "timeComplexities": [
      { "id": "time-1", "label": "O(n) using one pass with a shrinking window" },
      { "id": "time-2", "label": "O(n^2) after sorting all substrings" },
      { "id": "time-3", "label": "O(n log n) due to tree-ordered lookups per character" },
      { "id": "time-4", "label": "O(n^3) checking every substring for uniqueness" },
      { "id": "time-5", "label": "O(log n) because each duplicate halves the search" },
      { "id": "time-6", "label": "O(1) with constant-time random access" }
    ],
    "spaceComplexities": [
      { "id": "space-1", "label": "O(min(n, alphabet)) to store last seen indices" },
      { "id": "space-2", "label": "O(n^2) for a full duplicate matrix" },
      { "id": "space-3", "label": "O(n) for storing every substring discovered" },
      { "id": "space-4", "label": "O(log n) because only recursion depth matters" },
      { "id": "space-5", "label": "O(1) ignoring the hash map used for tracking" },
      { "id": "space-6", "label": "O(n log n) with balanced tree bookkeeping" }
    ]
  },
  "answerKey": {
    "algorithms": "alg-1",
    "implementations": "impl-1",
    "timeComplexities": "time-1",
    "spaceComplexities": "space-1"
  }
}
